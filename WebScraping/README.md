**Quick Walk through**

### Access Full Course:
- **Udemy:**  https://www.udemy.com/course/kubernetes-on-weekends/
- **Youtube:** https://www.youtube.com/watch?v=TSdsIP22klE&list=PLgDNNHx_Y9lLO8criL0mS75N9Q-yHi6l9 

## Aim
- To deploy a workload in kubernetes to perform web scrapping task of any website.
- We shall use various Kubernetes components to
    - Read configuration data {URL, FileName} from ConfigMap
    - Access the URL, collect its html and store in the FileName.html file
    - Storage should be persistent
    - With change in configuration data, program should refresh variables without restarting POD
    - Requests & Limits should be defined for the pod 
- Get familizrized with basic kubernetes components

## Kubernetes Concepts Discussed:
- Pod, ReplicaSet, Deployment
- ConfigMaps & Secrets
- Pod Troubleshooting
- How to execute your commands on a container
- Volumes - emptyDir, hostPath, Persistent Volume, Storage Class etc
- Resource - Limits & Requests

## Prerequistes
- Kubernetes Cluster
- Kubectl 
- VS Code
- Kubernetes extension
- Any other extension asked to install by VS Code

## Steps
- **01-simple-pod-running-our-command**
    - Start with a simple deployment inside which a pod running our command
- **02-added-env-vars-and-resource-request-limits**
    - Make the pod command configurable and add resource limits     
- **03-read-env-values-from-configmap**
    - Read the value of env variable from configmap
- **04-mount-configmap-as-volume**
    - Take advantage of real time value updates for volume mounts
- **05-update-env-vars-with-config-change**
    - Every time a value is updated inside configmap, pod should be able to consume it without having to restart the pod
- **06-emptyDir**
    - use a volume within the pod to store the data
- **07-hostpath**
    - use a volume to store the data in a directory in the node machine
- **08-pvc**
    - Store the data being generated by pod in a cloud drive



## What is Pod
A Pod is the smallest and simplest unit of deployment. It represents a single instance of a running process in a cluster.

A Pod is a logical host for one or more containers. The containers within a Pod share the same network namespace and can communicate with each other using localhost. They can also share the same storage volumes, which allows them to share data.

Pods are usually created and managed by a higher-level Kubernetes object called a Controller, which provides additional functionality such as scaling, self-healing, and rolling updates.

```
Imperative Commands:
kubectl run busybox --image=busybox

# To get help
kubectl run -h 

kubectl get pod
kubectl describe pod <podname>
kubectl logs <podname>

kubectl run busybox --image=busybox --dry-run=client -o=yaml >> pod.yaml

```


## What is ReplicaSet
A ReplicaSet is responsible for maintaining a stable set of replicas of a Pod, and it does this by creating or deleting Pods as needed. It monitors the state of the Pods it manages, and if a Pod fails or is deleted, it replaces it with a new one to maintain the desired number of replicas.

## What is Deployment
A Deployment provides a way to declaratively define the desired state of a Pod or a set of Pods. It takes care of creating, updating, and deleting ReplicaSets as needed to meet the desired state. It provides a way to perform rolling updates of an application by gradually replacing old Pods with new ones.

### Imperative Commands:
```
kubectl create deploy <deploymentname> --image=busybox --replicas=3

kubectl get deploy
kubectl describe deploy <deploymentname>

kubectl create deploy busybox-deploy --image=busybox --replicas=3 --dry-run=client -o=yaml >> deploy.yaml
```

### Declarative Statement:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: busybox-web-scraper
spec:
  selector:
    matchLabels:
      app: busybox-web-scraper
  replicas: 1
  template:
    metadata:
      labels:
        app: busybox-web-scraper
    spec:
      containers:
        - name: busybox
          image: busybox
          command: 
          - "/bin/sh"
          - "-c"
          - "echo received inputs: SCRAPING_URL : $SCRAPING_URL; \
             echo received inputs: FILENAME : $FILENAME; \
             wget -qO- http://www.techsckool.com/ --no-check-certificate > techsckool.html; \
             sleep 600"
```


## Resource - Requests & Limits

#### kubectl top pod
![alt](https://raw.githubusercontent.com/TechSckoolByVijay/Kubernetes-Demo-Series/main/WebScraping/readme.images/top-command.jpg)


#### to set requests and limits on pod
```
resources:
  requests:
    cpu: 2m
    memory: 5Mi
  limits:
    cpu: 20m
    memory: 20Mi
```


#### How to execute a command against a running container?
```
kubectl exec <podname> -- <your command> 
```

#### How to obtain and interactive shell attached to a running container?
```
kubectl exec -it <podname> -- <your command> 
```

### View Container Logs
```
kubectl logs <podname>
kubectl logs <podname> -c <containername>

# to keep getting new log messages
kubectl logs <podname> --follow
```

![alt](https://raw.githubusercontent.com/TechSckoolByVijay/Kubernetes-Demo-Series/main/WebScraping/readme.images/deploy-rs-pod.png)

## Kubernetes - ConfigMap?
- A ConfigMap is an API object used to store non-confidential data in key-value pairs. Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume.

- A ConfigMap allows you to decouple environment-specific configuration from your container images, so that your applications are easily portable.

### There are four different ways that you can use a ConfigMap to configure a container inside a Pod:
- Inside a container command and args
- Environment variables for a container
- Add a file in read-only volume, for the application to read
- Write code to run inside the Pod that uses the Kubernetes API to read a ConfigMap

### How to create ConfigMap
#### Imperative Command
` kubectl create configmap demoapp --from-literal=key1=value1`

### Generating declarative statement with imperative command
` kubectl create configmap demoapp --from-literal=key1=value1  --dry-run=client -o=yaml > configmap.yaml`


### How to use ConfigMap
1.)
```
  env:
    - name: SCRAPING_URL
      valueFrom:
        configMapKeyRef:
          name: demoapp
          key: SCRAPING_URL
```
2.) 
```
      volumeMounts:
        - name: config
          mountPath: /tmp
  volumes:
  - name: config
    configMap:
      name: demoapp
```

## Kubernetes - Secrets?
- A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. Such information might otherwise be put in a Pod specification or in a container image. Using a Secret means that you don't need to include confidential data in your application code.
- Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys.

### Uses for Secrets
There are three main ways for a Pod to use a Secret:
- As files in a volume mounted on one or more of its containers.
- As container environment variable.
- By the kubelet when pulling images for the Pod.

### How to create Secrets
```
Imperative Statement:
kubectl create secret generic my-secret --from-literal=key1=value
```

```
Declarative Statement 
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  key1: dmFsdWUx
  key2: dmFsdWUy
```


# Volume
- A volume is a directory that is accessible to all containers running in a pod. 
```
  volumes:
  - name:  output-volume
    persistentVolumeClaim:
      claimName: demoapp
  - name: config
    configMap:
      name: demoapp
```
## Persistent Volumes
- PersistentVolume (PV) and PersistentVolumeClaim (PVC) volumes provide persistent storage for stateful applications. PVs are storage resources that are provisioned by a cluster administrator, while PVCs are requests for storage made by applications.
  ```          
    volumeMounts:
    - name: output-volume
      mountPath: /tmp/output
    - name: config
      mountPath: /tmp
  ```

## emptyDir
- an emptyDir volume is a type of volume that is created when a pod is created and is deleted when the pod is deleted. The emptyDir volume is created on the same node where the pod is scheduled, and can be used to share data between containers running in the same pod.

- When multiple containers are running in the same pod, the emptyDir volume can be used to share data between them. This can be useful when one container generates data that another container needs to process.

- The emptyDir volume can be used to store temporary data that is not needed after the pod has been deleted. This can be useful for running jobs that require temporary storage.

## hostPath
- a hostPath volume is a type of volume that mounts a file or directory from the host node's filesystem into the pod. This can be useful for accessing host node resources from within a pod, or for sharing data between containers running on different nodes.


## emptyDir vs hostPath
- Scope: An emptyDir volume is scoped to the pod and is deleted when the pod is terminated. In contrast, a hostPath volume is scoped to the node and persists even if the pod is terminated.

- Persistence: An emptyDir volume is not persistent and data stored in it is lost if the pod is terminated. In contrast, a hostPath volume is persistent and data stored in it is retained even if the pod is terminated.

- Security: A hostPath volume can be a security risk, as it gives the pod access to the host node's filesystem. In contrast, an emptyDir volume does not pose a security risk, as it is scoped to the pod and does not give the pod access to the host node's filesystem.

- Use case: emptyDir volumes are typically used for temporary data storage within a pod, such as for caching or intermediate data storage during data processing. hostPath volumes are typically used for sharing data between containers running on different nodes, or for accessing host node resources from within a pod.

