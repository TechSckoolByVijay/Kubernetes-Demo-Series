hello you awesome people. Welcome to this interseting lecture. Allow me to share the purpose behind creating this demo. We've designed this demo specifically for IT professionals who have a basic understanding of Kubernetes (K8s) but haven't had hands-on experience yet. Don't worry, we're here to support you every step and ensure you get your hands dirty with K8s.  Our focus will primarily be on practical implementation rather than theoretical discussions. However, if you'd like to stay engaged, you can go through this article I've prepared. It follows the same steps we'll be covering in this demo. 

I'd love for you to try out the commands together with me. By the end of this demo, I promise you'll feel much more confident about Kubernetes concepts like deployment, pod, volume, configmap, and more. The reason for my promise is simple: we'll be tackling a real-world problem, and I'll demonstrate how to approach and solve it within the Kubernetes ecosystem. So let's dive in and have some fun while learning!  allright, lets start with this problem statement. So. our task is to find a way in kubernetes to grab the html of a given URL and store it in a file in such a way that it can be viewed later and essentially what I mean here is this file should remain available even if our program completes its execution. yes.

we want to run our web scrapping program, and because we are dealing with K8s, it has to run in a pod, which is the smallest and simplest unit of deployment. but POD can go down, and I dont want to manually bring it up everytime, if is stopped for whatever reason, so we need replicaset to manage our pod.  A ReplicaSet is responsible for maintaining a stable set of replicas of a Pod, and it does this by creating or deleting Pods as needed. It monitors the state of the Pods it manages, and if a Pod fails or is deleted, it replaces it with a new one to maintain the desired number of replicas.

A Deployment provides a way to declaratively define the desired state of a Pod or a set of Pods. It takes care of creating, updating, and deleting ReplicaSets as needed to meet the desired state. It provides a way to perform rolling updates of an application by gradually replacing old Pods with new ones.    so, it is like, in real world, almost, we never create a POD itself.. they eventually gets created as a result of Deployment, SS, job, DaemonSet etc, that is a different story. so here also what we will create is a deployment, which can have more than 1 replica and inside it we will speicfy our pod defination and essentiall the webscrapping logic or script which is our ultimate goal. Yeah. lets proceed.

This is my kubernetes cluster, deployed in Azure Cloud. and I will be ineteracting with this using kubectl commands from my system. All you need to do is grab your credentials, and we're good to go. For the scope of this demo, you can continue with any kubernets cluster of your choice, However in the last step, we will perform a step where azure storage class will be used, but it is ok to skip that particular step. Now, let's dive right in and create our deployment. We'll start with an imperative command, and then move on to a declarative one. You can use the following kubectl commands to get started: "kubectl create deploy" and "kubectl get deploy, rs, pod". Superb! Let's get started.  kubectl create deploy |||   kubectl get deploy, rs, pod ...

imperative commands are quick and easy to execute, offer more flexibility than declarative commands, and provide immediate feedback. However, they lack reproducibility, are harder to automate, and are more error-prone.    .. for example, easily, for the need coupple of more customizations, your imperative command can look like this, with no definate order of these parameteres, doesnt sound very readable isnt it. well the solution to all these problem is declarative statement. lets expolore this.

kubectl create deployment nginx-deployment --image=nginx --replicas=3 --port=80 --labels=app=nginx,env=prod --selector=app=nginx,env=prod --min-ready-seconds=30 --progress-deadline=120s --strategy=RollingUpdate --max-surge=1 --max-unavailable=0 --timeout=5s

well, because I have got the VS Code extension for k8s installed, I can just use this promot and select an appropriate template which I want to work on. If not this, we can generate this schema directly with the help of imperative command themselves. let me show you..

<<create deploy --dry-run=client>>file>> declarative statements are more reproducible, scalable, and easier to manage than imperative statements. However, they have a steeper learning curve, limited flexibility, and provide delayed feedback.

whichever way you create the alright.. so here we have got the structure to which we can add different layers to bring something meaningful out of it.

so as we show earlier in this diagram, deploy-rs,pod.. ppt and elaborate. <<image selection ppt, sword-knife>> 

<windows fan> so cant leave ms.. so if you are on non-ms, you perhaps have terminal where u can execute this statement.. I needed mobaxterm for this. lets execute this statement here.. and u can see. we are able to grab the html of this remote web page into this file. this is very smooth. let me add this to our pod defination.

you must be wondering, why this sleep 600?

